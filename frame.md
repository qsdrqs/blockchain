## 目的
使得整个区块链在整个过程中不会因为账本不一致而崩溃。

1. 最小化 attacker 被选举成为代表的可能性（因为 attacker 倾向于创造账本不一致）。

    解决方案：通过降低 attacker 的投票权。

2. 最小化 attacker 的账本传递给代表的可能性。

    解决方案：通过 neighbor 一致性检测。

3. 最小化 attacker 的账本传递给其他节点的可能性。

    解决方案：账本延迟更新机制，账本在每次更新之后才持久化成为认可的交易，否则会处于 Pending 状态。

## 解决的场景
1. 一个相互连通的去中心化网络交易流程，攻击者是其中一个节点。

2. 一个相互连通的去中心化网络交易流程，攻击者控制了其中一个节点。

## 选举方式
排名而不选举

## 投票权问题
DPoS 是根据拥有的财富数量决定投票权的大小。
不够好，攻击者投票权可能过大。

可以换一种方式，投票权根据（交易人数*中间 20% 平均交易额*log（连接数））（比如，这个主要为了规避 attacker 故意找几个人刷交易记录来提高自己的权重）
决定，这样投票权会集中于更资深的用户身上（更资深的用户会更在乎网络的安全性，破坏网络对他们产生的损失更大）。

在原有的投票权基础上，有一些特定条件会降低投票权。（因为是模型，所以所有参数可以在合理范围内自行决定）

1. 两个 neighbor 之间的交易记录不一致，投票权降低。

2. 该节点在网络中仅与一个节点相连，投票权降低。

3. 攻击者失误：包括 UA 频繁变更等（仅需要模拟实现即可）。

## 账本更新时间
代表们定时对账本进行签名，以担保账本的真实性。

对于每一个用户，当 80% 的代表达成一致时，才认为网络不被破坏，更新账本。
这个更新的前提是所有代表必须签名。

攻击者胜利条件：成功使得超过 20% 的代表收到并信任假账本。

代表签名问题：部分代表可能会同时收到多个账本，则对所有账本均进行签名，最后更新的账本是代表们签名数量最多的账本，以保证一致性。

## 具体工作
1. 需要一个公共账本，记录了所有的交易情况和所有用户的余额以及初始权重（通过计算得出）。

2. 对于每一个用户，有自己的公钥私钥用于签名，并且拥有一个账本，位置，通信长度，最大通信长度。

3. 存在一个很短的账本传播周期，两个相邻的节点会自动验证双方账本是否一致，如果不一致，则更新账本。

4. 在账本传播的过程中，触发 neighbor 一致性检测机制，该时刻会加大一个节点可以连接的其他节点个数，来判断是否存在账本不一致的问题。

5. 基于上述代表选举机制选举不超过 20% 的代表，以（权重、上一次是否是代表）为概率，再选取其中 50%，并在另一个时间周期后重新选举。

6. 所有账本在一段时间后需要所有代表的签名，且至少需要有 80% 的代表达成一致。

7. 一个图。

